---
title: "Reanalysis of nGBR harvest models"
output: html_notebook
---

```{r}
rm(list=ls())
#library(nloptr)
library(Rsolnp)
library(tidyverse)
```


This document describes the analysis of computing the missing juvenile survival and transition probabilities for green turtles in nGBR. 

```{r}
# Ts is the stage durations of various juvenile stages  (T in Caswell's book) - the last stage is assumed to be subadults, so their fecundity is not zero.
# VT is a vector variances of stage durations
# f is a vector of fecundities
define.matrix <- function(Ts = c(5, 5, 3), VT = c(1, 1, 1), f = c(65, 75), phi.1 = 0.3, phi.J = c(0.6, 0.7, 0.8), phi.A = 0.95){
  gam <- Ts/(VT + Ts)
  k <- round((Ts^2) / (VT + Ts))
  M.dim <- sum(k) + 2
  
  # juvenile stages (ks) + adult stages (length of fecundity) + first year
  M <- matrix(data = 0, 
              nrow = M.dim, 
              ncol = M.dim)
  
  for (j in 1:length(f)){
    M[1, (M.dim - j + 1)] <- f[length(f) - j + 1]
  }

  #M[1, (M.dim-1)] <- f[1]
  #M[1, M.dim] <- f[2]
  M[2, 1] <- phi.1
  M[M.dim, M.dim] <- phi.A

  l <- 1  
  for (j in 1:length(k)){
    for (i in 1:k[j]){
      M[(l + 1), (l + 1)] <- phi.J[j] * (1 - gam[j])
      M[(l + 2), (l + 1)] <- phi.J[j] * gam[j]
      l <- l + 1
    }
    
  }

  eig1 <- eigen(M)
  
  return(list(k = k,
              gam = gam,
              M = M,
              eigen1 = eig1$values[1]))
}

# These values will be changed according to appropriate values
in.list <- list(Ts = c(5, 5, 3),
                VT =  c(1, 1, 1),
                f =  c(65, 75), 
                phi.1 =  0.4,
                phi.J = c(0.5, 0.6, 0.7),
                phi.A = 0.95,
                lambda = 1.04)

M.1 <- define.matrix(Ts = in.list$Ts, VT = in.list$VT, f = in.list$f,
                     phi.1 = in.list$phi.1, phi.J = in.list$phi.J,
                     phi.A = in.list$phi.A) 

```

Next, create an objective function to find juvenile survival rates with constraints

```{r}
# objective function
# obj.fcn <- function(x){
#   M <- define.matrix(Ts = in.list$Ts, VT = in.list$VT, 
#                      f = in.list$f, phi.1 = in.list$phi.1, 
#                      phi.J = x, phi.A = in.list$phi.A)
#   
#   eig.1 <- M$eigen1
#   
#   return(abs(eig.1 - in.list$lambda))
# }
# 
# eval_g0 <- function(x){
#   return(matrix(c(1,-1,0,0,1,-1), nrow = 2, ncol = 3) %*% c(x[1], x[2], x[3]))
# }

# the inequality constraints didn't work so well in nloptr package.
# estim <- nloptr(x0 = c(0.5, 0.7, 0.9),
#                 eval_f = obj.fcn,
#                 eval_g_ineq = eval_g0,
#                 lb = c(0,0,0), 
#                 ub = c(1.0,1.0,1.0),
#                 opts = list("algorithm" = "NLOPT_LN_COBYLA",
#                             "xtol_abs" = c(1.0e-18, 1.0e-18, 1.0e-18),
#                             "maxeval" = 50000))

#"NLOPT_LN_NELDERMEAD" - worked for without contraint
#"NLOPT_GN_AGS" - does not work
#"NLOPT_GN_ORIG_DIRECT" - didn't work so well. 
#                            ,
#                            "maxeval" = 10000

# Using Rsolnp package
obj.fcn <- function(x){
  M <- define.matrix(Ts = in.list$Ts, VT = in.list$VT, 
                     f = in.list$f, phi.1 = in.list$phi.1, 
                     phi.J = x, phi.A = in.list$phi.A)
  
  eig.1 <- M$eigen1
  
  return(abs(eig.1 - in.list$lambda))
}

eval_g0 <- function(x){
  
  return(c(x[1] - x[2], x[2] - x[3]))
}

estim <- gosolnp(#pars = c(0.5, 0.7, 0.9), 
                 fun = obj.fcn,
                 ineqfun = eval_g0,
                 LB = c(0.0, 0.0, 0.0), 
                 UB = c(1.0, 1.0, 1.0),
                 ineqLB = c(-1.0, -1.0),
                 ineqUB = c(0.0, 0.0),
                 distr = c(1,1,1),
                 control = list(outer.iter = 1000,
                                inner.iter = 5000,
                                tol = 1.0e-12,
                                delta = 1.0e-10))


```

Using the estimated juvenile survival rates, figure out the entire matrix.

```{r}
#in.list$phi.J <- estim$solution   # for nloptr

in.list$phi.J <- estim$pars
M.2 <- define.matrix(Ts = in.list$Ts, VT = in.list$VT, 
                     f = in.list$f, phi.1 = in.list$phi.1, 
                     phi.J = in.list$phi.J, phi.A = in.list$phi.A)


```


